#                                                                             #
#
#==============================================================================
#  Copyright (c) 2002 ROMS/TOMS Group, version 2.0                          ===
#========================================================= Hernan G. Arango ===
#                                                                             #
# Input parameters can be entered in ANY order, provided that the parameter   #
# KYWORD (usually, upper case) is typed correctly followed by "="  or "=="   #
# symbols. Any comment lines are allowed and must begin with an exclamation   #
# mark (#) in column one.  Comments may  appear to the right of a parameter   #
# specification to improve documentation.  All comments will ignored during   #
# reading.  Blank lines are also allowed and ignored. Continuation lines in   #
# a parameter specification are allowed and must be preceded by a backslash   #
# (\).  In some instances, more than one value is required for a parameter.   #
# If fewer values are provided, the  last value  is assigned for the entire   #
# parameter array.  The multiplication symbol (*),  without blank spaces in   #
# between, is allowed for a parameter specification.  For example, in a two   #
# grids nested application:                                                   #
#                                                                             #
#    AKT_BAK == 2*1.0d-6  2*5.0d-6              # m2/s                        #
#                                                                             #
# indicates that the first two entries of array AKT_BAK,  in fortran column-  #
# major order, will have the same value of "1.0d-6" for grid 1,  whereas the  #
# next two entries will have the same value of "5.0d-6" for grid 2.           #
#                                                                             #
# In multiple levels of nesting and/or multiple connected domains  step-ups,  #
# "Ngrids" entries are expected for some of these parameters.  In such case,  #
# the order of the entries for a parameter is extremely important.  It  must  #
# follow the same order (1:Ngrids) as in the state variable declaration. The  #
# USER may follow the above guidelines for specifying his/her values.  These  #
# parameters are marked by "==" plural symbol after the KEYWORD.              #
#                                                                             #
#==============================================================================
#
# NOTICE: Input parameter units are specified within brakets and default
# ******  values are specified within braces.
#
# Switch to control the computation of biology within nested and/or multiple
# connected grids.

Lbiology: TRUE

# Maximum number of iterations to achieve convergence of the nonlinear
# solution.

BioIter: 1

# Model-specific parameters
#
#************************************************************************
# TODO: Insert all model-specific parameters here
# (standard_input.bpardict)
#************************************************************************


#************************************************************************
# TODO: The next section includes values applied on a per-tracer basis.
# Replace the placefolder values with a single default value for all bio 
# tracers, or a list of tracer-specific values
#************************************************************************

# Lateral, constant, harmonic/biharmonic horizontal diffusion of biological
# tracer: [1:NBT,Ngrids].

TNU2: 0.0                     # [m2/s]
TNU4: 0.0                     # [m4/s]

# Vertical mixing coefficients for biological tracers: [1:NBT,Ngrids].

AKT_BAK: 0.0                                # [m2/s]

# Nudging/relaxation time scales, inverse scales will be computed
# internally: [1:NBT,Ngrids].

TNUDG: 0.0            # [days]

# Set horizontal and vertical advection schemes for biological tracers.
# A different advection scheme is allowed for each tracer. For example,
# a positive-definite (monotonic) algorithm can be activated for
# salinity and biological tracers, while a different one is set for
# temperature. [1:NAT+NPT,Ngrids] values are expected.
#
#   Keyword    Advection Algorithm
#
#   A4         4th-order Akima (horizontal/vertical)
#   C2         2nd-order centered differences (horizontal/vertical)
#   C4         4th-order centered differences (horizontal/vertical)
#   HSIMT      3th-order HSIMT-TVD (horizontal/vertical)
#   MPDATA     recursive flux corrected MPDATA (horizontal/vertical)
#   SPLINES    parabolic splines (only vertical)
#   SU3        split third-order upstream (horizontal/vertical)
#   U3         3rd-order upstream-biased (only horizontal)
#
# The user has the option of specifying the full Keyword or the first
# two letters, regardless if using uppercase or lowercase. If nested
# grids, specify values for each grid.
#
Hadvection: HSIMT

Vadvection: HSIMT

# Adjoint-based algorithms can have different horizontal and schemes
# for active and inert tracers.

ad_Hadvection: U3                             # idbio(:), compact

ad_Vadvection: C4                             # idbio(:), compact

# Logical switches (TRUE/FALSE) to activate writing of biological tracers
# into HISTORY output file: [1:NBT,Ngrids].

Hout:
  idTvar: TRUE
  idBeTvar: TRUE
  idIceVar: TRUE
  
Aout:
  idTvar: TRUE
  idBeTvar: TRUE
  idIceTvar: TRUE

# Logical switches (TRUE/FALSE) to activate writing of biological diagnostics
# into DIAGNOSTICS output file

# Primary production-related


Dout(iilims)  == F
Dout(iiliml)  == F
Dout(inolims) == F
Dout(inoliml) == F
Dout(inhlims) == F
Dout(inhliml) == F
Dout(ifelims) == F
Dout(ifeliml) == F

# Fluxes between state variables
Dout(iflx_Gpp_NO3_PhS)   == T
Dout(iflx_Gpp_NO3_PhL)   == T
Dout(iflx_Gpp_NH4_PhS)   == T
Dout(iflx_Gpp_NH4_PhL)   == T
Dout(iflx_Gra_PhS_MZL)   == F
Dout(iflx_Gra_PhL_MZL)   == F
Dout(iflx_Ege_MZL_Det)   == F
Dout(iflx_Gra_PhS_Cop)   == F
Dout(iflx_Gra_PhL_Cop)   == F
Dout(iflx_Gra_MZL_Cop)   == F
Dout(iflx_Gra_IPhL_Cop)  == F
Dout(iflx_Ege_Cop_DetF)  == F
Dout(iflx_Gra_PhS_NCaS)  == F
Dout(iflx_Gra_PhL_NCaS)  == F
Dout(iflx_Gra_MZL_NCaS)  == F
Dout(iflx_Gra_IPhL_NCaS) == F
Dout(iflx_Ege_NCaS_DetF) == F
Dout(iflx_Gra_PhS_NCaO)  == F
Dout(iflx_Gra_PhL_NCaO)  == F
Dout(iflx_Gra_MZL_NCaO)  == F
Dout(iflx_Gra_IPhL_NCaO) == F
Dout(iflx_Ege_NCaO_DetF) == F
Dout(iflx_Gra_PhS_EupS)  == F
Dout(iflx_Gra_PhL_EupS)  == F
Dout(iflx_Gra_MZL_EupS)  == F
Dout(iflx_Gra_Cop_EupS)  == F
Dout(iflx_Gra_IPhL_EupS) == F
Dout(iflx_Gra_Det_EupS)  == F
Dout(iflx_Gra_DetF_EupS) == F
Dout(iflx_Ege_EupS_DetF) == F
Dout(iflx_Gra_PhS_EupO)  == F
Dout(iflx_Gra_PhL_EupO)  == F
Dout(iflx_Gra_MZL_EupO)  == F
Dout(iflx_Gra_Cop_EupO)  == F
Dout(iflx_Gra_IPhL_EupO) == F
Dout(iflx_Gra_Det_EupO)  == F
Dout(iflx_Gra_DetF_EupO) == F
Dout(iflx_Ege_EupO_DetF) == F
Dout(iflx_Gra_Cop_Jel)   == F
Dout(iflx_Gra_EupS_Jel)  == F
Dout(iflx_Gra_EupO_Jel)  == F
Dout(iflx_Gra_NCaS_Jel)  == F
Dout(iflx_Gra_NCaO_Jel)  == F
Dout(iflx_Ege_Jel_DetF)  == F
Dout(iflx_Mor_PhS_Det)   == F
Dout(iflx_Mor_PhL_Det)   == F
Dout(iflx_Mor_MZL_Det)   == F
Dout(iflx_Mor_Cop_DetF)  == F
Dout(iflx_Mor_NCaS_DetF) == F
Dout(iflx_Mor_EupS_DetF) == F
Dout(iflx_Mor_NCaO_DetF) == F
Dout(iflx_Mor_EupO_DetF) == F
Dout(iflx_Mor_Jel_DetF)  == F
Dout(iflx_Res_PhS_NH4)   == T
Dout(iflx_Res_PhL_NH4)   == T
Dout(iflx_Res_MZL_NH4)   == T
Dout(iflx_Res_Cop_NH4)   == T
Dout(iflx_Res_NCaS_NH4)  == T
Dout(iflx_Res_NCaO_NH4)  == T
Dout(iflx_Res_EupS_NH4)  == T
Dout(iflx_Res_EupO_NH4)  == T
Dout(iflx_Res_Jel_NH4)   == T
Dout(iflx_Rem_Det_NH4)   == T
Dout(iflx_Rem_DetF_NH4)  == T
Dout(iflx_Nit_NH4_NO3)   == F
Dout(iflx_Gra_Det_Ben)   == F
Dout(iflx_Gra_DetF_Ben)  == F
Dout(iflx_Gra_PhS_Ben)   == F
Dout(iflx_Gra_PhL_Ben)   == F
Dout(iflx_Gra_DetB_Ben)  == F
Dout(iflx_Exc_Ben_NH4)   == F
Dout(iflx_Exc_Ben_DetB)  == T
Dout(iflx_Res_Ben_NH4)   == T
Dout(iflx_Mor_Ben_DetB)  == F
Dout(iflx_Rem_DetB_NH4)  == T
Dout(iflx_Gpp_INO3_IPhL) == T
Dout(iflx_Gpp_INH4_IPhL) == T
Dout(iflx_Res_IPhL_INH4) == T
Dout(iflx_Mor_IPhL_INH4) == T
Dout(iflx_Nit_INH4_INO3) == F
Dout(iflx_Twi_IPhL_PhL)  == F
Dout(iflx_Twi_INO3_NO3)  == F
Dout(iflx_Twi_INH4_NH4)  == F
Dout(iflx_Ver_PhS_DetB)  == F
Dout(iflx_Ver_PhS_Out)   == F
Dout(iflx_Ver_PhL_DetB)  == F
Dout(iflx_Ver_PhL_Out)   == F
Dout(iflx_Ver_Det_DetB)  == F
Dout(iflx_Ver_Det_Out)   == F
Dout(iflx_Ver_DetF_DetB) == F
Dout(iflx_Ver_DetF_Out)  == F
Dout(iflx_Ver_NCaO_DetB) == F
Dout(iflx_Ver_NCaS_DetF) == F
Dout(iflx_Ver_NCaS_DetB) == F
Dout(iflx_Frz_PhL_IPhL)  == F
Dout(iflx_Frz_NO3_INO3)  == F
Dout(iflx_Frz_NH4_INH4)  == F
Dout(iflx_Frz_TIC)       == T
Dout(iflx_Frz_Alk)       == F
Dout(iflx_Adv_NO3)       == F
Dout(iflx_Adv_NH4)       == F
Dout(iflx_Adv_PhS)       == F
Dout(iflx_Adv_PhL)       == F
Dout(iflx_Adv_MZL)       == F
Dout(iflx_Adv_Cop)       == F
Dout(iflx_Adv_NCaS)      == F
Dout(iflx_Adv_EupS)      == F
Dout(iflx_Adv_NCaO)      == F
Dout(iflx_Adv_EupO)      == F
Dout(iflx_Adv_Det)       == F
Dout(iflx_Adv_DetF)      == F
Dout(iflx_Adv_Jel)       == F
Dout(iflx_Adv_Fe)        == F
Dout(iflx_Adv_TIC)       == F
Dout(iflx_Adv_Alk)       == F
Dout(iflx_Adv_Oxyg)      == F

# Net production
Dout(iprod_PhS)    == F
Dout(iprod_PhL)    == F
Dout(iprod_MZL)    == F
Dout(iprod_Cop)    == F
Dout(iprod_NCaS)   == F
Dout(iprod_EupS)   == F
Dout(iprod_NCaO)   == F
Dout(iprod_EupO)   == F
Dout(iprod_Jel)    == F
Dout(iprod_Ben)    == F
Dout(iprod_IcePhL) == F

# Other fluxes

Dout(itotprod) == F
Dout(itotresp) == F
Dout(itotrem)  == F

# 2D diagnostics

Dout(io2flx)   == F
Dout(ico2flx)  == F
Dout(ipco2)    == F
Dout(iclimice) == F # Note: same as hice unless CLIM_ICE_1D is on

# End-of-timestep (memory) biomass
# Note: these are used to calculate advective/diffusive fluxes within the code, and are
# unlikely to be needed outside that context.  Recommend to keep F.

Dout(ibiomem_NO3)  == F
Dout(ibiomem_NH4)  == F
Dout(ibiomem_PhS)  == F
Dout(ibiomem_PhL)  == F
Dout(ibiomem_MZL)  == F
Dout(ibiomem_Cop)  == F
Dout(ibiomem_NCaS) == F
Dout(ibiomem_EupS) == F
Dout(ibiomem_NCaO) == F
Dout(ibiomem_EupO) == F
Dout(ibiomem_Det)  == F
Dout(ibiomem_DetF) == F
Dout(ibiomem_Jel)  == F
Dout(ibiomem_Fe)   == F
Dout(ibiomem_TIC)  == F
Dout(ibiomem_Alk)  == F
Dout(ibiomem_Oxyg) == F

# Lateral boundary conditions

LBC(isTvar) ==   RadNud  RadNud  Clo  Clo \ #  1. NO3
                 RadNud  RadNud  Clo  Clo \ #  2. NH4
                 RadNud  RadNud  Clo  Clo \ #  3. PhS
                 RadNud  RadNud  Clo  Clo \ #  4. PhL
                 RadNud  RadNud  Clo  Clo \ #  5. MZL
                 RadNud  RadNud  Clo  Clo \ #  6. Cop
                 RadNud  RadNud  Clo  Clo \ #  7. NCaS
                 RadNud  RadNud  Clo  Clo \ #  8. EupS
                 RadNud  RadNud  Clo  Clo \ #  9. NCaO
                 RadNud  RadNud  Clo  Clo \ # 10. EupO
                 RadNud  RadNud  Clo  Clo \ # 11. Det
                 RadNud  RadNud  Clo  Clo \ # 12. DetF
                 RadNud  RadNud  Clo  Clo \ # 13. Jel
                 RadNud  RadNud  Clo  Clo \ # 14. Fe
                 RadNud  RadNud  Clo  Clo \ # 15. TIC
                 RadNud  RadNud  Clo  Clo \ # 16. Alk
                 RadNud  RadNud  Clo  Clo   # 17. Oxyg
                 
LBC(isIvar) ==   Clo     Clo     Clo  Clo \ # 1. IcePhL
                 Clo     Clo     Clo  Clo \ # 2. IceNO3
                 Clo     Clo     Clo  Clo   # 3. IceNH4

# Logical switches (TRUE/FALSE) to specify which variables to process for
# tracers climatology: [NBT,Ngrids] values are expected. See glossary below
# for details.

 LtracerCLM == 17*F
 LnudgeTCLM == 17*F
 LtracerSrc == 17*F

